Chess Game Patch Notes
Day 1: May 9, 2020 ~3 hours

Added a Coord class. Trivial class, merely a way to write an x position and a y position on the board. A little annoying to combine with 2D arrays, since coordinates usually go (x, y) but matrices go (r, c) --> (y, x). At the moment, coordinates for the board go (r,c), so (2,0) is actually down 2 and hugging the left corner.

Added a Board class. Only member variable is a pointer to a 2D array of pieces. Currently, only meaningful constructor takes in an 8x8 array of characters, and transforms each entry with an 'N' to a white knight, and all other entries to the nullptr. Has a print function that will print out the board again, representing 'N' for knight, and '.' for empty (nullptr). Also has a trivial getter function that can access and modify (?) the pointer to a piece at a given coordinate.

Added a Piece class. It is an abstract base class, with a pointer to a board, a coordinate, and a boolean representing white or black. Trivial getter functions and member variables for those three things. Has a boolean that returns if a move is legal, however only checks if that square is in bounds, not inhabited by a friendly piece, and king is not in check. It does not disallow, for example a bishop to move like a rook.
Contains two pure virtual functions: type, and legal move. Type is trivial, merely a string that returns the Piece type. legalMoves is what makes up for the shortcomings of legalMove, it returns a set of all legal moves, by taking all of the squares a piece could theoretically move to and passing it through legal move.

Added a Set class, essentially my own Linked List class that acts as an arbitrary-sized dynamic array of coordinates.

Added a Knight class. Inherits fncts from base class, overrides virtual functions. Has a board, coord, and color.

Remarks: Should I worry about using int vs short for indices, since they will not go out of the 0-8 range?
Made use of operator overloading in Coord.h
Concept of friendly fire in legalMove, and check
Boards "have" pieces, and pieces "have" boards. Thus, to break this cyclical dependence, I had to make use of forward declaration.
Can't move through pieces unless knight
How will we differentiate white from black?

Day 2: May 10, 2020 ~1 hour

Board can add a piece. Board is also a lot bigger, and white is now color that is now a char that is either 'W' or 'B', and type is also a char instead of a string.
Added an operator= overload to Coord so we can make a contains function in set
Made a contains function in set
movePiece function in Board, rn a void function, I may change it to bool and it may take input from cin
Made King template, still need to implement checks + checkmate
Changed board construction from char to string to create colors as well
Added all legal moves to print all legal moves of every piece
Capturing:

Remarks: Need to get around to destructors at some point.
Go through and mark fncts const
Need to add check!

Day 3: June 24, 2020 ~2hrs

Working on a function "canReachCoord" that returns a list of pointers to all pieces of a given color that can reach a square.
NOTE: use legalMoves().contains(c), not legalMove(c). legalMove is just an auxiliary function that doesn't check all functionality.
Started to implement check. 

Remarks: 
Need to ensure that moving a piece won't result in check for your own king!
Work on being able to move pieces.

Day 4: June 25, 2020 ~3 hrs

Working on a copy constructor for Board so we can evaluate potential future states.
Made a functions that returns a vector of vectors of strings (basically a 2D array) and we can reconstruct future states with that
Trying to figure out exactly how it works

Day 5: June 26, 2020 ~1.5 hrs

Fixed it so pieces can't execute a move that would result in their own king being in check

Expected Stylistic Changes for the day:
Comment everything
Fixed memory leaks
Ran in g++ for the first time, went perfectly
Now removes pieces from the piece list when captured

Remarks: 
Research Graphics Libraries for xCode
Do we always want to exit game on error?
Idea for bishop / rooks / queens: we can recursively check next squares and stop if we come to an enemy, friend, etc.

Day 6: June 27, 2020 ~2.5 hrs

Messed around a bit in opneGL, it's a huge headache so I'm not really going to bother with graphics libraries. Changed coordinates to standard chess coordinates.

Process of adding a new Piece:
Need to have a header file
Needs to have a cpp file that defines legalMoves
Needs to update board constructor to allow for that piece

Problem with rook: he can go through enemy players since we only check if they are legal moves by square, and legal moves don't take into consideration capturing. Need to fix this efficiently so bishop and queen will work!
Fixed rook!
Implemented Bishops too!

Next time: Figure out what to do with error messages / maybe don't make it crash every time
Add queens
Add pawns (will be tricky)
Evaluation functions

Day 7: June 29, 2020 ~2.5 hrs

Adding Queens - pretty easy, just need to include bishop and rook moving functionality
Pawns - will be difficult, due to special moves (capturing different than moving), and "directionality" - based on if white or black.
Able to eradicate copy constructor of vectors... and we can actually do it the const Board& other way. This is good because now we can pass on information regarding if pawns or kings or rooks have moved, etc.

Removed moveRaw
Added castling
Added a "has moved" tag

Need to combine the concept of a legal move with the concept of a legal state... doesn't make sense to consider them separately

Still need to add:
Promotion
Checkmate
En passant

Idea for combining: instead of creating a new board to check if every move would lead to the king being in check (which would be extremely time consuming for the compiler), just eliminate the moves from the legalMoves set. Perhaps add another member of piece that tracks if that piece is pinned or not. Essentially, isolate all factors i put into legalState and see if we can simply fix legal moves through new members / member functions.

Day 8: June 30, 2020 ~2.5 hours

Get Ray will return a set of coordinates diagonal / straight from a piece

Very time consuming to check all possible pieces to see if a move would lead to a same-side check, so for now, we're just returning a list of pseudo-legal moves and checking the states when the time comes.

What are characteristics of a good evaluation function? What algorithms are we going to have to write to help the evaluation function?


Todo: condense legalState and legalMove into one entity
Tackle promotions
Start researching minimax and AB pruning
Checkmates

Problem: king cannot move 2 in front of pawns...

Worked on ray... seems to be a problem with the WhitePieces / BlackPieces iterator...
Next time: Finish getRay, isPinned, and eliminate legalState

Day 9: July 1, 2020 ~5 hrs

Get Ray works
Problem with starting the board on a non-standard configuration. It assumes that certain rooks are in their spots, that is how they check for castling rights. Obviously, this is a problem if we don't start out with rooks in the corner. Hopefully, I won't even have to address this issue.

Working on a "getPinned" function to eliminate checking for legalStates... idea is pinned pieces will only be able to move along the ray axis. Right now, there is a problem with getPinned, work on this.

I fixed getPinned, so now we know which pieces are pinned. How does this affect how the piece is moved? For example, a pinned piece may still move, if it's with the ray direction.

Need to define the notion of four axis: U, L, UL, UR. Each pin is only a pin with respect to certain axis. Perhaps add a piece member "pinned" and specify which axis the pin is with respect to. Certain pieces can't be pinned, like knights, kings, etc so this won't increase the runtime significantly.

Introduce directionality to rays w/ char
V: vertical rays
H: horizontal rays
D: upper left rays
d: upper right rays
N: no ray

Successfully rigorously defined a pinned piece, now to eradicate legalState we simply need to ensure that the king doesn't move into check or stay in check.
Change canReachCoord and put in auxiliary?

To do next time: 
clean up unnecessary functions
Work on detecting if king is in check. We may need another function like canReachCoord, except it considers all pseudo-legal moves
Change canReachCoord so it only considers pseudo-legal moves
run in g32
Promotions 
En passant
King can't move 2 in front of pawns ( or in front of )
Still not quite right, try playing game and inputting and seeing if it can handle everything
Has to do with castling, my method is so janky right now

Day 10: July 2, 2020 ~8 hrs

Todo: Promotions (fixed castling already!)

King can't go in front of pawn
Evaluation functions
Minimax
AB pruning
Storing evals in hash tables?

Fixed pins AND problem with king not being able to move in front of pawns by altering the pseudoLegalMove function in Pawns.cpp to only include the capturing squares.

Solution to being able to capture protected piece and moving away from bishops/rooks in same ray while under attack:
Revamp pseudoLegalMove to include last piece if same color, or if encounters king of opposite color as first piece, rays pierce fully through the board
Kings cannot capture a pseudoProtected piece.
If in direct ray with no pieces, King cannot move along that ray

Another case to consider: if king is in check, the only legal moves are those that lead to the king not being in check

Find clause responsible for checking if king is in check and condense into legalMoves

Final Clause: King cannot be in check at the end of turn.
    We have already ruled out king moving into check and moving into discovered check
    Essentially, we now have to account for if the king is in check at the beginning of a round, he must either capture the offending piece, move the king, or interpose a piece.
    Case Not Attacked: don't need to do anything
    Case Attacked by 1 Piece: move king (so don't do anything to king's coords), interpose a piece (so rule out all legalMoves that aren't in the ray), or capture offending pice
    Case Attacked by 2+ pieces: can only escape this by moving king, so rule out any move except a king move
Finished^

Trouble with promotions: because pieces list needs to be updated / purged when we promote, otherwise everything else is messed up.

Command for running in clang++
clang++ -std=c++0x *.cpp

Day 11: July 4, 2020 ~5 hours

To do: Make updatePinDir a part of movePiece
Redo castling mechanics
Promotions

Problem with bishops queens and rooks: automatically stops checking squares if one coord in the ray is not a legal move, but this is not correct. For example, a bishop could move back to 3 squares to block a check. It wouldn't be able to just move back one!

At this point, I'm essentially done with the mechanics of the game. The only things not strictly implemented are en passant, and a non-queen promotion, and draw rules but they aren't integral to the engine at this point. It takes about ~150ms on average to find the set of all strictly legal moves for a given side, which I would like to cut down in the future. For now, I'm researching evaluation algorithms. I realize I'll need to write some helper functions, like one that returns a set of all pieces protecting a given piece.

Day 12: July 5, 2020 ~6 hours

I optimized the legalMove function, and wrote a Tuple struct to record algorithm time for finding all legal moves as a function of total moves available
I will do a regression and analyze the results
Also need to make it so an illegal suggestion does not crash the program without calling destructors

Almost done - just some slight problems with castling. Can still castle through check (sometimes), and sometimes can't castle at all

Idea: (first save), make a new function "getKingPseuso" and use instead of getCoordPseudo so we don't waste any time in legalMoves().

Everything is fixed. Now, moving onto the evaluation algorithm portion.
A good eval algorithm: runs fast, and is accurate
One often comes at the expense of another

AT THIS POINT: On average, finding AND iterating through all legal moves of a given side takes ~5ms.

My idea: split up eval into 3 categories: opening, middle-game, endgame.

Opening: default state of game

Middlegame: (10 or fewer major/minor pieces), OR (all minor pieces from at least one side are developed AND at least one queen is developed AND one side has moved king))

Endgame: 6 or fewer major/minor pieces

General Priorities:

Special Priorities: (function of opening, middle, or end)

Opening:

Middlegame:

Endgame:

Day 13: July 6, 2020 ~5 hrs

Problem with getRay: stops when it hits a friendly / enemy piece
Make some function that updates which pieces are protected and which pieces it attacks
Now each piece has two lists of pieces: one that stores all pieces that legally defend it (e.g. it excludes bishops that have a clear line of sight to a knight from that knight's defenders if that bishop is pinned in the opposite direction), 

Fix: moveRaw to optimize theoretical calculations (movePiece is too slow/robust)
Give (negative) weight to attacked pieces... right now we only give a positive bonus to defended pieces.

Day 14: July 7, 2020 ~4 hours

moveRaw really only saves about 5 ms, is it really worth it?
Todo: tweak material evaluations
Add positional bonuses - center controlling squares, penalty for early queen moves, bonus for castling, king safety indicator
Perhaps start differentiating the opening / middle / endgame?
Thinking about how the computer will handle checkmate / stalemate

Definition of game stage: (note piece in this context means bishop, knight, rook, queen)
Endgame: <= 6 pieces left
Middlegame: 7, 8, 9, or 10 pieces left, or 5+ developed white pieces or 5+ developed black pieces
Opening: Everything else

General evaluation techniques:
Adding up material from white and subtracting material from black
Bonus to defended pieces
	Varies in proportion to worth of defended pieces
	Varies inversely proportional to worth of defender pieces
Penalty to attacked pieces
	Varies in proportion to worth of attacked piece
	Varies inversely proportional to worth of attacking piece
Mobility bonus (more legal moves is a bonus)

Pawn structure - TBI
King safety - TBI

K - 0
P - 1
B - 3
N - 3
R - 5
Q - 9

Stalemate: king not in check and no legal moves (eval -> 0)
Checkmate: king in check and no legal moves (eval -> ± 100)

GameState bonuses:
Opening: Middle square control
Middle:
End: passed pawns, protected passed pawns

Day 15: July 8, 2020 ~1 hour

All I did was think about algorithms for evaluating the worth of pieces that are attacked / defended by other pieces.
Essentially, if a piece (worth P) is attacked and undefended, simply evaluates to -P
If a piece has a minimum-valued attacker worth A, and IS defended, this evaluates to
-P + A

Potential problems:
Kings are worth 0 points right now and obviously you can't capture back if there are multiple attackers
What if there are more attackers than defenders?

->The latter problem will be solved with minimax
->The former problem will probably require a structural change in the Auxiliary::evalPiece function

Day 16: July 9, 2020 ~2 hrs

-Pretty much finished opening and middle game evaluation

This is how the opening is evaluated:
     -A simple linear combination of the worth of the pieces for each side
     -A mobility bonus
     -A detector if a piece is in danger of being captured (evalPiece)
     -A penalty for moving rooks / queen too early
     
     -A king safety bonus (TO BE ADDED)

This is how the middlegame is evaluated (with respect to opening):
    -A simple linear combination of the worth of the pieces for each side
    -A mobility bonus (50% higher than in the opening, but still slight)
    -A detector if a piece is in danger of being captured (evalPiece)
    -Penalty for moving rooks / queen too early is REMOVED
    -An added bonus for overprotection
    -An added penalty for unprotected pawns that guard others
    -Center controlling bonus reduced to 33%
    -Added penalty for isolated / doubled pawns
     
    -A king safety bonus (TO BE ADDED)

This is how the endgame is evaluated (with respect to middlegame):
     
     -A simple linear combination of the worth of the pieces for each side
     -Mobility bonus removed
     -A detector if a piece is in danger of being captured (evalPiece)
     -Overprotection bonus removed
     -An added penalty for unprotected pawns that guard others (like before)
     -Center controlling bonus removed
     -Penalty for isolated / doubled pawns INCREASED weighting
     
     -A king activity bonus (TO BE ADDED)
     -A passed pawn (protected / candidate) analyzer
     -A king safety bonus (TO BE ADDED)

TODO next time:

Add a king safety bonus
Add a king activity bonus
Add a passed pawn detector (protected, when is it a candidate, etc.)

-Make sure a stalemate and a checkmate always evaluate to 0, ±infinity (respectively)
-Make eval time trials and optimizations 
-Organize and comment
-Potential problems: Kings are worth 0 points right now and obviously you can't capture back if there are multiple attackers
-Will probably require a structural change in the Auxiliary::evalPiece function

Day 17: July 10, 2020 ~2 hrs

-I saved time by changing the method that tracks all the pieces that can reach the king in Piece::legalMoves() to simply the king's attackers
This should be exactly the same, but if I have any legal move problems later, especially with respect to the king not detecting when he is in check, I can try changing it back

-The only problem is that if a piece is attacking a king but also pinned against their own king, technically the king has no attacker, so we need to change this
basically, we ignore the pinDir limitations if the piece it is attacking is a king
(fixed)

King attacking is actually fixed, since it won't be a legal move unless there are no defenders, don't need to worry about it

change in x::update() <- piece's derived classes
I implemented the kingSafety method to be used in the opening / middlegame

Day 18: July 11, 2020 ~4 hrs

Todo:

-Add a king activity bonus - TBI endgame
-Add a passed pawn detector (protected, when is it a candidate, etc.) - TBI endgame
-Make sure a stalemate and a checkmate always evaluate to 0, ±infinity (respectively) (always)
-Make eval time trials and optimizations 
-Organize and comment

Later: need to automatically eval stuff like KNK endgames to stalemate
I have basically finished the first draft of the evaluation function, but it might fail in the endgame / fail to find checkmates or recognize stalemates

For now, I'm going to plan / research the minimax and ab pruning part, and perhaps re-research graphics libraries.

Day 19: July 12, 2020 ~4 hrs

1st half step works need recursive case (fixed as of ~8 pm)

-Pseudocode for recommendMove
(takes in a board, a color, and a depth)
Note: a tuple is a struct with a pointer to a piece, a coordinate, and a double that stores the evaluation value

Base Case: (depth = 1)
Iterate through pieces
	Iterate through legal moves
		Create a new temp board
		Move the piece to the given square in the temp board
		Evaluate that position
		If first position or that eval is better (defined as < for black or > for 		white), create a tuple and store into the return value
Return tuple of best value

Recursive Case: (depth > 1)
Same as base case, but instead of using a static eval to evaluate the position, call recommendMove and pass in (depth - 1) as the parameter.

Note: Does not properly handle checkmate or stalemate. Probably is a fault of Auxiliary::reccomendMove(Board*,char,int) in the base case (since it calls for static eval... maybe the recursive too...)

Todo tmrw: Optimize minimax, AB pruning, hash table?

Day 20: July 13, 2020 ~3 hours
-I implemented AB pruning
Next: transposition table
How can I find a cheap operator== for board?
Need to make cheap operator== for Piece first

2 boards are the same IFF all pieces are in the same position
The turns are the same
Perhaps have 2 hash tables?
We need to make an eval function independent of turn so we can efficiently store
Instead of centerBonus use piece square tables?

Day 20: July 18, 2020

Making Board::operator==
First, need to make Piece::operator==

~69 hrs

Kasparov v Topalov

e2e4 d7d6 d2d4 g8f6 b1c3 g7g6 c1e3 f8g7 d1d2 c7c6 f2f3 b7b5 g1e2 b8d7 e3h6 g7h6 d2h6 c8b7 a2a3 e7e5 e1c1 d8e7 c1b1 a7a6 e2c1 e8c8 c1b3 e5d4 d1d4 c6c5 d4d1 d7b6 g2g3 c8b8 b3a5 b7a8 f1h3 d6d5 h6f4 b8a7 h1e1 d5d4 c3d5 b6d5 e4d5 e7d6 d1d4 c5d4 e1e7 a7b6 f4d4 b6a5 b2b4 a5a4 d4c3 d6d5 e7a7 a8b7 a7b7 d5c4 c3f6 a4a3 f6a6 a3b4 c2c3 b4c3 a6a1 c3d2 a1b2 d2d1 h3f1 d8d2 b7d7 d2d7 f1c4 b5c4 b2h8 d7d3 h8a8 c4c3 a8a4 d1e1 f3f4 f7f5 b1c1 d3d2 a4a7 

BN 2 2 
WN 5 2 2.12535e-314
BN 2 0 
WN 5 5 0.16
BN 2 7 
WN 5 5 0.18
BN 2 5 
WN 5 2 0.02
BP 2 0 
WN 5 5 0.16
BP 3 0 
WN 5 5 0.2
BP 2 1 
WN 5 5 0.14
BP 3 1 
WN 5 5 0.48
BP 2 2 
WN 5 2 0.04
BP 3 2 
WN 5 5 0.1
BP 2 3 
WB 3 1 0.15
BP 3 3 
WP 3 4 2.12535e-314
BP 2 4 
WB 3 1 0.19
BP 3 4 
WP 5 0 2.12535e-314
BP 2 5 
WN 5 5 0.04
BP 3 5 
WQ 3 7 0.05
BP 2 6 
WN 5 5 0.14
BP 3 6 
WN 6 4 4.97519e-15
BP 2 7 
WN 5 5 0.16
BP 3 7 
WN 5 5 0.2

BN 2 2 
WP 4 3 2.12466e-314
BN 2 0 
WB 2 0 1.26
BN 2 7 
WP 4 3 1.04
BN 2 5 
WN 5 2 0.56
BP 2 0 
WP 4 3 1.02
BP 3 0 
WP 4 3 1.06
BP 2 1 
WP 4 3 1
BP 3 1 
WB 3 1 1.91
BP 2 2 
WP 4 3 0.82
BP 3 2 
WP 4 3 0.96
BP 2 3 
WB 3 1 1.35
BP 3 3 
WB 3 1 0.43
BP 2 4 
WP 4 3 0.7
BP 3 4 
WP 4 3 0.54
BP 2 5 
WQ 3 7 1.01
BP 3 5 
WP 3 5 1.26
BP 2 6 
WP 4 3 1
BP 3 6 
WP 4 3 1.08
BP 2 7 
WP 4 3 1.02
BP 3 7 
WP 4 3 1.06

Todo:
Think about what I would want to implement later
Think about how I might implement that and what I would need
Redo the legalMoves search with that in mind
E.g. how can we have a board class design that allows us to cheaply copy, evaluate, and store / compare boards?

How can we have an eval function independent of turn?

For example, should we have a list of pieces? How are we going to get legalMoves? How can we order it so that the pieces that are captured are first searched? 

What is iterative deepening?

Can we use a lazy eval alg. 
Can we store the total points of the board so as not to waste time iterating through all of the pieces
